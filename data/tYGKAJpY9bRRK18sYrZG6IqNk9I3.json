{"tYGKAJpY9bRRK18sYrZG6IqNk9I3": {"info": {"acc": 0, "backgroundColor": "dimgray", "cssScene": true, "cursorMaxXYZ": {"x": 1, "y": 1, "z": 5}, "cursorMinXYZ": {"x": -1, "y": -1, "z": -5}, "cursorRadius": 0.02, "date": "2024-09-13T14:21:49.789Z", "delayDuration": 0.7094113260152879, "experiment": "mental-nav", "experimentSourceCode": "// Third-party imports\nimport {\n  AlwaysStencilFunc,\n  CircleGeometry,\n  Clock,\n  Color,\n  MathUtils,\n  Mesh,\n  MeshBasicMaterial,\n  MeshStandardMaterial,\n  OrthographicCamera,\n  PlaneGeometry,\n  ReplaceStencilOp,\n  SphereGeometry,\n  TextureLoader,\n  Vector2,\n  Vector3,\n} from 'three';\n\n// Package imports\nimport {\n  Experiment,\n  Block,\n  DisplayElement,\n  Survey,\n  InstructionsPanel,\n  CSS2D,\n} from 'ouvrai';\nimport { fileContents } from './fileContents.js';\nimport { sampleDelay,randomUniform } from './utils.js';\nimport { degToRad, radToDeg } from 'three/src/math/MathUtils.js';\n/*\n * Main function contains all experiment logic. At a minimum you should:\n * 1. Create a `new Experiment({...config})`\n * 2. Initialize the state machine with `exp.state.init(states, changeFunc)`\n * 3. Create stimuli and add them with `exp.sceneManager.scene.add(...objects)`\n * 4. Create trial sequence with `exp.createTrialSequence([...blocks])`\n * 5. Start the main loop with `exp.start(calcFunc, stateFunc, displayFunc)`\n * 6. Design your experiment by editing `calcFunc`, `stateFunc`, and `displayFunc`\n */\n\n\nfunction worldToPixel(worldPosition, camera, screenWidth, screenHeight) {\n  // Convert world position to NDC\n  const ndc = worldToNDC(worldPosition, camera);\n  \n  // Convert NDC to screen coordinates\n  return ndcToScreen(ndc, screenWidth, screenHeight);\n}\n\nfunction worldToNDC(worldPosition, camera) {\n  const vector = new Vector3();\n  vector.copy(worldPosition).project(camera);\n  return vector;\n}\n\nfunction pixelToNDCSize(pixelSize) {\n  // Convert pixelX to NDC x\n  return (pixelSize / window.innerHeight) * 2;\n  \n}\n\nfunction ndcToScreen(ndc, screenWidth, screenHeight) {\n\n  const x = (ndc.x + 1) / 2 * screenWidth;\n  const y = (-ndc.y + 1) / 2 * screenHeight; // Y is inverted\n  return { x, y };\n}\n\nfunction vaToPixels(angleDegrees, distance, screenHeightcm) {\n  // Convert angle from degrees to radians\n  \n  const dpp =  radToDeg(Math.atan2(0.5 * screenHeightcm, distance)) / (0.5 * window.innerHeight); //degree per pixel\n  const pixelSize = angleDegrees / dpp;\n\n  return pixelSize;\n}\n\nfunction vaToNdC(angleDegrees,distance,screenHeightcm){\n  // const dpp =  radToDeg(Math.atan2(0.5 * screenHeightcm, distance)) / (0.5 * screenSize); //degree per pixel\n  const pixelSize = vaToPixels(angleDegrees,distance,screenHeightcm);\n  // console.log(\"pxel size\",pixelSize);\n  const ndc = pixelToNDCSize(pixelSize);\n  // console.log(\"ndc\",ndc);\n  return ndc;\n}\n\nfunction ndcToVA(ndc,distance,screenHeightcm){\n  const dpp =  radToDeg(Math.atan2(0.5 * screenHeightcm, distance)) / (0.5 * window.innerHeight); //degree per pixel\n  \n  const pixels = ((ndc+1)/2)* window.innerHeight;\n  \n  const va = pixels * dpp;\n  \n  return pixels;\n}\n\nasync function main() {\n  /*\n   * The first step is always to create a new Experiment({...config}) with your configuration options.\n   * Ouvrai configuration options are documented in the Experiment class.\n   * You can also provide other experiment-level variables here as additional fields.\n   * All values in the configuration object will be saved in your data.\n   * You can add variables throughout the experiment using `exp.cfg.VARNAME = VALUE`.\n\n*/\n\n// Example usage\n  \n  const exp = new Experiment({\n    // Options to make development easier\n    devOptions: {\n      skipConsent: true,\n      saveTrialList: false,\n      allowExitFullscreen: false, // set to flase\n      allowExitPointerlock: false, //set to false\n    },\n\n    // Platform settings\n    requireDesktop: true,\n    requireChrome: false,\n\n    // Three.js settings\n    orthographic: true,\n    cssScene: true,\n\n    // Scene quantities\n    // Assume meters and seconds for three.js, but note tween.js uses milliseconds\n    cursorRadius: 0.02,\n    cursorMinXYZ: new Vector3(-1, -1, -5),\n    cursorMaxXYZ: new Vector3(1, 1, 5),\n    targetRadius: 0.04,\n    homeRadius: 0.05,\n    score:0,\n    acc:0,\n\n    // Procedure\n    delayDuration: sampleDelay(0.5,1.5),\n\n    experimentSourceCode: fileContents,\n    searchParams : new URLSearchParams(window.location.search),\n\n  });\n\n  const screenWidth = window.innerWidth;\n  const screenHeight = window.innerHeight;\n  console.log(\"ActuaLScreenwidth\",screenWidth,screenHeight)\n    \n  const frustumWidth = exp.sceneManager.camera.right - exp.sceneManager.camera.left;\n  const frustumHeight = exp.sceneManager.camera.top - exp.sceneManager.camera.bottom;\n\n  console.log(\"camera\",exp.sceneManager.camera);\n  /*\n   * Initialize visual stimuli with three.js\n   */\n  const config = JSON.parse(\"{\n    \"imageset\":1,\n    \"landmarkHeight\":5, \n    \"landmarkWidth\":5,\n    \"landmarkY\":0.35,\n    \"targetY\":-0.35,\n    \"cursorRadius\":0.3,\n    \"interLandmarkDistance\":5, \n    \"stepSizes\":[20,15],\n    \"numLandmarks\":9,\n    \"tolerance\":0.25,\n    \"initialTrials\": 90,\n    \"accThresholds\":[0.75,0.75],\n    \"stopKey\": \"s\",\n    \"patchRadius\":3,\n    \"ndots\":900,\n    \"dotRadius\":0.005,\n    \"dotLife\":4,\n    \"blockSpeed\":15,\n    \"screenHeightcm\":21.42,\n    \"objectDistance\": 57 \n}\");\n  //Display a cricle with random dots\n\n  const segments = 64; // more segments = more smooth\n\n\n  const patchgeometry = new CircleGeometry(config.patchRadius, segments);\n  const patchmaterial = new MeshBasicMaterial({color:0x000000});\n\n  const patch = new Mesh(patchgeometry,patchmaterial)\n  patch.position.setX(0,0,0);\n  exp.sceneManager.scene.add(patch)\n\n  const dots = [];\n\nfor (let i = 0; i < config.ndots; i++) {\n  // Generate a random radius between config.dotRadius / 2 and config.dotRadius\n  const randomRadius = (Math.random() * (config.dotRadius / 2)) + (config.dotRadius / 2);\n\n  // Create the geometry with the random radius\n  const dotGeometry = new CircleGeometry(randomRadius, segments);\n  const dotMaterial = new MeshBasicMaterial({ color: 0xc0c0c0 });\n\n  // Create the dot mesh\n  const dot = new Mesh(dotGeometry, dotMaterial);\n  \n  // Set a random position for the dot\n  setRandomPosition(dot);\n\n  // Assign a random life value to the dot\n  dot.life = Math.random() * config.dotLife; // in distance\n\n  // Add the dot to the scene and store it in the dots array\n  exp.sceneManager.scene.add(dot);\n  dots.push(dot);\n}\n\n  const objectDistance = config.objectDistance; //cm\n  const screenHeightcm = config.screenHeightcm; //screenHeightcm\n\n  let moveLeft = {lm:false,dot:false};\n\n  let moveRight = {lm:false,dot:false};\n  let isKeyDown = false;\n\n  const landmarkHeight = Math.abs(vaToNdC(config.landmarkHeight,objectDistance,screenHeightcm));\n  const landmarkWidth = Math.abs(vaToNdC(config.landmarkWidth,objectDistance,screenHeightcm));\n\n  console.log(\"NDC H,w\",landmarkHeight,landmarkWidth)\n\n  const interlmdistance = Math.abs(vaToNdC(config.interLandmarkDistance,objectDistance,screenHeightcm));\n  const landmarks = [];\n  const textureLoader = new TextureLoader();\n  const imageset = config.imageset;\n  const numLandmarks = config.numLandmarks;\n  const images = [...Array(numLandmarks).keys()].map(num => `landmarks/images/imageset${imageset}/${num}.jpg`)\n  \n  const geometry = new PlaneGeometry(landmarkWidth, landmarkHeight);\n\n  let clock = new Clock();\n\n  images.forEach((image, index) => {\n    const texture = textureLoader.load(image); // Replace with the path to your image\n    const material = new MeshBasicMaterial({ map:texture });\n    const lm = new Mesh(geometry, material);\n    lm.position.setX(parseInt(index * (landmarkWidth + interlmdistance)));\n    lm.position.setY(config.landmarkY);\n\n    // Create a central fixation dot\n    const dotGeometry = new SphereGeometry(0.01, 32, 32); // Adjust the radius as needed\n    const dotMaterial = new MeshBasicMaterial({ color: 0xff0000 }); // Red dot\n    const fixationDot = new Mesh(dotGeometry, dotMaterial);\n\n    // Position the fixation dot at the center of the landmark\n    fixationDot.position.set(0, 0, 0); // Assuming the landmark's center is (0, 0, 0)\n\n    // Add the fixation dot to the landmark\n    lm.add(fixationDot);\n\n    landmarks.push(lm);\n});\n\nconst maskGeometry = new PlaneGeometry(landmarkWidth*5,landmarkHeight);\nconst maskMaterial = new MeshBasicMaterial({ color: 0x242424, depthWrite: false, stencilWrite: true, stencilFunc: AlwaysStencilFunc, stencilRef: 1, stencilMask: 0xff, stencilFail: ReplaceStencilOp, stencilZFail: ReplaceStencilOp, stencilZPass: ReplaceStencilOp });\nconst mask = new Mesh(maskGeometry, maskMaterial);\n\n\nconst maskGeometry2 = new PlaneGeometry(landmarkWidth*5,landmarkHeight);\nconst maskMaterial2 = new MeshBasicMaterial({ color:  0x242424, depthWrite: false, stencilWrite: true, stencilFunc: AlwaysStencilFunc, stencilRef: 1, stencilMask: 0xff, stencilFail: ReplaceStencilOp, stencilZFail: ReplaceStencilOp, stencilZPass: ReplaceStencilOp });\nconst mask2 = new Mesh(maskGeometry2 , maskMaterial2);\n\n\nconst maskGeometry3 = new PlaneGeometry(landmarkWidth*3,landmarkHeight);\nconst maskMaterial3 = new MeshBasicMaterial({ color: 0x242424, depthWrite: false, stencilWrite: true, stencilFunc: AlwaysStencilFunc, stencilRef: 1, stencilMask: 0xff, stencilFail: ReplaceStencilOp, stencilZFail: ReplaceStencilOp, stencilZPass: ReplaceStencilOp });\nconst mask3 = new Mesh(maskGeometry3 , maskMaterial3);\n// exp.sceneManager.scene.add(mask,mask2,mask3)\n\nlandmarks.forEach((landmark)=>{\n  landmark.visible = false;\n  exp.sceneManager.scene.add(landmark);\n});\n\n  const target  = new Mesh(\n    geometry,\n    new MeshStandardMaterial() // we will set color in displayFunc()\n  );\n\n  const cursor = new Mesh(\n    new SphereGeometry(exp.cfg.cursorRadius),\n    new MeshStandardMaterial({ color: 'red' })\n  );\n  cursor.position.setZ(exp.cfg.homeRadius + exp.cfg.cursorRadius);\n  \n  const home = new Mesh(\n    new SphereGeometry(exp.cfg.cursorRadius*2),\n    new MeshStandardMaterial({ color: 'white' })\n  )\n\n  home.position.set(0,0,0);\n  cursor.position.setY(0,0,0);\n\n  exp.sceneManager.scene.add(home,cursor)\n\n  /*\n   * You can display overlay text on the scene by adding CSS2D to cssScene\n   */\n  const overlayText = new CSS2D({color:0xffffff});\n  overlayText.object.position.set(0, 0.7);\n  overlayText.element.innerText = '';\n  overlayText.element.style.color = 'white';\n\n  exp.sceneManager.cssScene.add(overlayText.object);\n\nfunction setRandomPosition(dot){\n  const angle = Math.random() * 2 * Math.PI;\n  const r = config.patchRadius * Math.sqrt(Math.random());  // Uniform distribution within the circle\n  const x = r * Math.cos(angle);\n  const y = r * Math.sin(angle);\n  dot.position.set(x,y,0)\n}\n\n// const dot = new Mesh(dotGometry, dotMaterial);\n// const angle = 0;\n// const x = Math.cos(angle) * 1;\n// const y = Math.sin(angle) * 1;\n// dot.position.set(x,y,0)\n// exp.sceneManager.scene.add(dot);\n\n  // Display a score\n  const scoreText = new CSS2D();\n  scoreText.object.position.set(0.9,0.7,0.01);\n  scoreText.element.innerText = ' Score: ';  \n  scoreText.element.style.color = 'white';\n\n  /*\n   * Create trial sequence from array of block objects.\n   */\n  const frameRate = 60;\n  const initStep = (config.interLandmarkDistance/0.5)/frameRate;\n  const stepSizes = config.stepSizes;\n  if (exp.cfg.searchParams.get(\"COHORT\")==1){ // use multiple speeds\n    \n    exp.createTrialSequence([\n      new Block({\n        variables: {\n          startId : Array.from({ length: numLandmarks*(numLandmarks-1) * stepSizes.length }, (_, i) => Math.floor(i / (numLandmarks-1))%numLandmarks),\n          // startId : Array.from({ length:  5 }, (_, i) => 0),\n          targetId :  Array.from({ length: numLandmarks*  stepSizes.length }, (_, i) => [...Array(numLandmarks).keys()].filter(num => num !== i % numLandmarks)).flat(),\n          // targetId :  Array.from({ length:5}, (_, i) => 8),\n\n        },\n        options: {\n          name: `COHORT : ${exp.cfg.searchParams.get('COHORT')}, DAY: ${exp.cfg.searchParams.get('DAY')}, SPEEDS: 3`,\n          reps: 1,\n          shuffle: true,\n        },\n      }),\n      new Block({\n        variables: {\n          startId : Array.from({ length: numLandmarks*(numLandmarks-1) * stepSizes.length }, (_, i) => Math.floor(i / (numLandmarks-1))%numLandmarks),\n          // startId : Array.from({ length:  5 }, (_, i) => 0),\n          targetId :  Array.from({ length: numLandmarks*  stepSizes.length }, (_, i) => [...Array(numLandmarks).keys()].filter(num => num !== i % numLandmarks)).flat(),\n          // targetId :  Array.from({ length:5}, (_, i) => 8),\n\n        },\n        options: {\n          name: `COHORT : ${exp.cfg.searchParams.get('COHORT')}, DAY: ${exp.cfg.searchParams.get('DAY')}, SPEEDS: 3`,\n          reps: 1,\n          shuffle: true,\n        },\n      }),\n      new Block({\n        variables: {\n          startId : Array.from({ length: numLandmarks*(numLandmarks-1) * stepSizes.length }, (_, i) => Math.floor(i / (numLandmarks-1))%numLandmarks),\n          // startId : Array.from({ length:  5 }, (_, i) => 0),\n          targetId :  Array.from({ length: numLandmarks*  stepSizes.length }, (_, i) => [...Array(numLandmarks).keys()].filter(num => num !== i % numLandmarks)).flat(),\n          // targetId :  Array.from({ length:5}, (_, i) => 8),\n\n        },\n        options: {\n          name: `COHORT : ${exp.cfg.searchParams.get('COHORT')}, DAY: ${exp.cfg.searchParams.get('DAY')}, SPEEDS: 3`,\n          reps: 1,\n          shuffle: true,\n        },\n      }),\n    ]);\n  }else{ // use single speed for train and different speed for test\n  exp.createTrialSequence([ //training block with 1x speed \n    new Block({\n      variables: {\n        startId : Array.from({ length: numLandmarks*(numLandmarks-1) * 1 }, (_, i) => Math.floor(i / (numLandmarks-1))%numLandmarks),\n        // startId : Array.from({ length:  5 }, (_, i) => 0),\n        targetId :  Array.from({ length: numLandmarks * 1  }, (_, i) => [...Array(numLandmarks).keys()].filter(num => num !== i % numLandmarks)).flat(),\n        // targetId :  Array.from({ length:5}, (_, i) => 8),\n        train : true,\n        // stepSize : Array.from({ length:5}, (_, i) => stepSize),\n      },\n      options: {\n        name: `COHORT : ${exp.cfg.searchParams.get('COHORT')}, DAY: ${exp.cfg.searchParams.get('DAY')}, SPEEDS: 1`,\n        reps: 1,\n        shuffle: true,\n      },\n    }),\n    new Block({ //testing block with 2x and 0.5 x speed \n      variables: {\n        startId : Array.from({ length: numLandmarks*(numLandmarks-1) *  (stepSizes.length -1) }, (_, i) => Math.floor(i / (numLandmarks-1))%numLandmarks),\n        // startId : Array.from({ length:  5 }, (_, i) => 0),\n        targetId :  Array.from({ length: numLandmarks* (stepSizes.length -1)  }, (_, i) => [...Array(numLandmarks).keys()].filter(num => num !== i % numLandmarks)).flat(),\n        // targetId :  Array.from({ length:5}, (_, i) => 8),\n        train:false,\n        // stepSize : Array.from({ length:5}, (_, i) => stepSize),\n      },\n      options: {\n        name: `COHORT : ${exp.cfg.searchParams.get('COHORT')}, DAY: ${exp.cfg.searchParams.get('DAY')} , SPEEDS: 2`,\n        reps: 1,\n        shuffle: true,\n      },\n    }),\n    new Block({ //testing block with 2x and 0.5 x speed \n      variables: {\n        startId : Array.from({ length: numLandmarks*(numLandmarks-1) *  (stepSizes.length -1) }, (_, i) => Math.floor(i / (numLandmarks-1))%numLandmarks),\n        // startId : Array.from({ length:  5 }, (_, i) => 0),\n        targetId :  Array.from({ length: numLandmarks* (stepSizes.length -1)  }, (_, i) => [...Array(numLandmarks).keys()].filter(num => num !== i % numLandmarks)).flat(),\n        // targetId :  Array.from({ length:5}, (_, i) => 8),\n        train:false,\n        // stepSize : Array.from({ length:5}, (_, i) => stepSize),\n      },\n      options: {\n        name: `COHORT : ${exp.cfg.searchParams.get('COHORT')}, DAY: ${exp.cfg.searchParams.get('DAY')} , SPEEDS: 2`,\n        reps: 1,\n        shuffle: true,\n      },\n    }),\n    new Block({ //testing block with 2x and 0.5 x speed \n      variables: {\n        startId : Array.from({ length: numLandmarks*(numLandmarks-1) *  (stepSizes.length -1) }, (_, i) => Math.floor(i / (numLandmarks-1))%numLandmarks),\n        // startId : Array.from({ length:  5 }, (_, i) => 0),\n        targetId :  Array.from({ length: numLandmarks* (stepSizes.length -1)  }, (_, i) => [...Array(numLandmarks).keys()].filter(num => num !== i % numLandmarks)).flat(),\n        // targetId :  Array.from({ length:5}, (_, i) => 8),\n        train:false,\n        // stepSize : Array.from({ length:5}, (_, i) => stepSize),\n      },\n      options: {\n        name: `COHORT : ${exp.cfg.searchParams.get('COHORT')}, DAY: ${exp.cfg.searchParams.get('DAY')} , SPEEDS: 2`,\n        reps: 1,\n        shuffle: true,\n      },\n    }),\n  ]);\n  }\n  /*\n   * You must initialize an empty object called trial\n   */\n  let trial = {};\n\n  /**\n   * An instructions panel overlaid in the top-right of the screen.\n   * Keep these instructions short. Use CSS2D to overlay instructions on the scene.\n   */\n  exp.instructions = new InstructionsPanel({\n    content: `Use the mouse/trackpad to hit the targets.\nTry to hit as many targets as possible!`,\n  });\n\n  /**\n   * Ask questions at the end of the experiment with the Survey class.\n   * You probably don't need to ask for funding agency required demographic information.\n   * On Prolific, most participants have already provided this information.\n   * On Mechanical Turk, Ouvrai collects this information separately on the HIT posting.\n   */\n\n  exp.survey = new Survey();\n\n  exp.survey.addQuestion({\n    type: 'list',\n    name: 'device',\n    message:\n      'Did you use a keyboard or something else for this experiment?',\n    choices: ['Keyboard', 'Other'],\n    options: { required: true },\n  });\n\n  exp.survey.addQuestion({\n    type: 'list',\n    name: 'hand',\n    message: 'Which hand did you primarily use during the experiment?',\n    choices: ['Right', 'Left'],\n    options: { required: true },\n  });\n\n  /**\n   * Initialize Finite State Machine (FSM) that manages the flow of your experiment.\n   * You will define the behavior and transitions of the FSM below in stateFunc().\n   */\n  exp.state.init(\n    [\n      'CONSENT',\n      'SIGNIN',\n      'SETUP',\n      'START',\n      'DELAY',\n      'INITIAL',\n      'TARGET',\n      'GO',\n      'VISUAL',\n      'MENTAL',\n      'MOVING',\n      'STOP',\n      'FINISH',\n      'ADVANCE',\n      'SURVEY',\n      'CODE',\n      'FULLSCREEN',\n      'POINTERLOCK',\n      'DATABASE',\n      'BLOCKED',\n    ],\n    handleStateChange\n  );\n  /*\n   * Add a custom event handler that moves the cursor in response to mouse/trackpad inputs\n   */\n  document.body.addEventListener('mousemove', handleMouseMove);\n  document.body.addEventListener('keydown', handleKeyDown);\n  document.body.addEventListener('keyup',handleKeyUp);\n  // Start the main loop! These three functions will take it from here.\n  exp.start(calcFunc, stateFunc, displayFunc);\n  /**\n   * Use `calcFunc` for calculations used in _multiple states_\n   */\n  function calcFunc() {\n    // Objects are in 3D space so we copy to Vector2 to ignore the depth dimensionh\n    let cursPosXY = new Vector2().copy(cursor.position);\n    let homePosXY = new Vector2().copy(home.position);\n    let targPosXY = new Vector2().copy(trial.targetId===undefined?cursor.position:landmarks[trial.targetId].position);\n\n    if (exp.state.current == 'STOP'){ \n      target.distance = Math.abs(targPosXY.x - homePosXY.x); \n    target.reached =  target.distance <= config.tolerance * landmarkWidth;\n    }\n\n    cursor.atHome =\n      cursPosXY.distanceTo(homePosXY) <\n      exp.cfg.homeRadius - exp.cfg.cursorRadius;\n\n    // cursor.atTarget =\n    //   cursPosXY.distanceTo(targPosXY) <\n    //   exp.cfg.targetRadius - exp.cfg.cursorRadius;\n\n    // Determine if fullscreen and pointerlock are required\n    exp.fullscreen.required = exp.pointerlock.required =\n      exp.state.between('SETUP', 'ADVANCE') ||\n      exp.state.between('FULLSCREEN', 'POINTERLOCK');\n  }\n\n  /**\n   * Define your procedure as a switch statement implementing a Finite State Machine.\n   * Ensure that all states are listed in the array given to `exp.state.init()`\n   * @method `exp.state.next(state)` Transitions to new state on next loop.\n   * @method `exp.state.once(function)` Runs function one time on entering state.\n   */\n  function stateFunc() {\n    /**\n     * If one of these checks fails, divert into an interrupt state.\n     * Interrupt states wait for the condition to be satisfied, then return to the previous state.\n     * Interrupt states are included at the end of the stateFunc() switch statement.\n     */\n    if (exp.databaseInterrupt()) {\n      exp.blocker.show('database');\n      exp.state.push('DATABASE');\n      return;\n    } else if (exp.fullscreenInterrupt()) {\n      exp.blocker.show('fullscreen');\n      exp.state.push('FULLSCREEN');\n      return;\n    } else if (exp.pointerlockInterrupt()) {\n      exp.blocker.show('pointerlock');\n      exp.state.push('POINTERLOCK');\n      return;\n    }\n\n    switch (exp.state.current) {\n      // CONSENT state can be left alone\n      case 'CONSENT':\n        exp.state.once(function () {\n          if (exp.checkDeviceCompatibility()) {\n            exp.state.next('BLOCKED');\n          } else {\n            exp.consent.show();\n          }\n        });\n        if (exp.waitForConsent()) {\n          exp.state.next('SIGNIN');\n        }\n        break;\n\n      // SIGNIN state can be left alone\n      case 'SIGNIN':\n        if (exp.waitForAuthentication()) {\n          exp.state.next('SETUP');\n        }\n        break;\n\n      // The following states should be modified as needed for your experiment\n\n      case 'SETUP':\n        if (exp.cfg.searchParams.get(\"COHORT\") == 2) {\n          if (exp.trialNumber % config.blockSpeed === 0) {\n            let previousSpeed = exp.trials[trial.trialNumber - 1]?exp.trials[exp.trialNumber - 1].speed:Math.random() * 3;\n            let availableSpeeds = [0, 1].filter(speed => speed !== previousSpeed);\n            exp.trials[exp.trialNumber].speed = availableSpeeds[Math.floor(Math.random() * availableSpeeds.length)];\n        }else{\n          exp.trials[exp.trialNumber].speed = exp.trials[exp.trialNumber-1].speed\n        }\n\n      } else if (exp.cfg.searchParams.get(\"COHORT\") == 1) {\n        // Handle Cohort 2 logic here\n        if (exp.trialNumber+1 <= config.initialTrials) {\n            // Initial trials: use the same speed for all intial visual trials\n            exp.trials[exp.trialNumber].speed = 1; // Assuming the speed for initial trials is 1, adjust as needed\n        } else {\n          let previousSpeed = exp.trials[trial.trialNumber - 1].speed;\n          let availableSpeeds = [1]\n            if (exp.trialNumber % config.blockSpeed === 0) {\n              // // Change speed every blockSpeed trials\n              availableSpeeds = availableSpeeds.filter(speed => speed !== previousSpeed);\n              exp.trials[exp.trialNumber].speed = availableSpeeds[Math.floor(Math.random() * availableSpeeds.length)];\n          }else{\n            exp.trials[exp.trialNumber].speed = previousSpeed==1?availableSpeeds[Math.floor(Math.random() * availableSpeeds.length)]:exp.trials[exp.trialNumber-1].speed            \n          }\n        }\n      } else{\n        trial.stepSize = config.stepSizes[1]\n      }\n        \n        // Start with a deep copy of the initialized trial from exp.trials\n        trial = structuredClone(exp.trials[exp.trialNumber]);\n        trial.trialNumber = exp.trialNumber;\n        trial.startTime = performance.now();\n        // Reset data arrays\n        trial.t = [];\n        trial.state = [];\n        trial.posn = [];\n        trial.stateChange = [];\n        trial.stateChangeTime = [];\n        trial.attempt = 1;\n        // Initialize trial parameters\n        trial.demoTrial = exp.trialNumber === 0;\n        trial.stepSize = config.stepSizes[trial.speed]\n        // target.position.setY(trial.targetDistance * trial.targetDirection);\n        // trial.startId = 5;\n        // trial.targetId = 3;\n        trial.isTrain = true;\n        exp.cfg.acc = exp.cfg.score/(exp.trialNumber+1)\n        if(exp.cfg.searchParams.get('DAY')<= config.accThresholds.length){ // for training days indicated  by number of thresholds\n          if (exp.trialNumber <= config.initialTrials)\n            {\n              trial.isTrain = true;\n             }\n          else{\n            trial.isTrain = false;\n          }\n          // else{\n          //   if(exp.cfg.acc >= config.accThresholds[exp.cfg.searchParams.get('DAY')-1]){\n          //     trial.isTrain = false;\n          //   }else{\n          //     trial.isTrain = true;\n          //   }\n          // }\n        }\n        else{\n          trial.isTrain = false; // for other days use mental nav\n        }\n\n        if(exp.cfg.searchParams.get('DAY')>=5){\n          // trial.stepSize = 0.05// draw from cont dist ();\n          trial.stepSize = randomUniform(0.009,0.026); // Example: uniform between 0 and 1\n            \n        }\n        // console.log(\"visua\u00a7l\",trial.isTrain,config.initialTrials)\n\n        target.material.map = textureLoader.load(images[trial.targetId]);\n        target.position.setY(config.targetY);\n        exp.sceneManager.scene.add(target)\n        target.visible = false;\n        mask3.visible = true;\n        if (cursor.atHome) {\n          exp.state.next('START');\n        }\n// Set the speed for the trial (it will be the same for the next 15 trials)\n\n        break;\n\n      case 'START':\n        exp.state.once(() => {\n          trial.trueTime = Math.abs(landmarks[trial.targetId].position.x-landmarks[trial.startId].position.x)/vaToNdC(trial.stepSize,objectDistance,screenHeightcm)*1000;\n          overlayText.element.innerText = 'Go to the home position. \n Press s Key to End the experiment';\n          \n\n        landmarks.forEach((lm,index)=>{\n          lm.position.setX((index - trial.startId) * (landmarkWidth + interlmdistance));\n          if(trial.isTrain){\n            lm.visible = trial.isTrain;\n          }else{\n            lm.visible = lm.position.x == 0;\n          }\n        })\n\n          mask3.visible = true;\n\n        });\n        if (!cursor.atHome) {\n          overlayText.element.innerText = 'Go to the home position. \n Press s Key to End the experiment';\n          exp.state.next('SETUP')\n        }\n        else{\n          overlayText.element.innerText = '';\n          exp.state.next('INITIAL');\n        }\n        break;\n      \n        case 'INITIAL':\n          exp.state.once(()=>{\n            target.visible = false;\n            mask3.visible = true;\n            mask2.position.setX(-1.3);\n            mask.position.setX(1.3);\n          })\n\n          if (!cursor.atHome) {\n            overlayText.element.innerText = 'Go to the home position. \n Press s Key to End the experiment';\n            exp.state.next('START')\n          } else if (exp.state.expired(sampleDelay(0.5,1.5))) {\n              exp.state.next('DELAY');\n          }\n          break;\n\n      case 'DELAY': // BLANK WHEN DELAY 0.5x 0.75x 1x\n        if (!cursor.atHome) {\n          overlayText.element.innerText = 'Go to the home position. \n Press s Key to End the experiment';\n          exp.state.next('START');\n        } else if (exp.state.expired(sampleDelay(0.5,1.5))) {\n            if (mask3.visible){\n              exp.state.next('TARGET');  \n            }else{\n              exp.state.next('GO');\n            }\n        }\n        break;\n\n      case 'TARGET':\n        exp.state.once(()=>{\n          mask3.visible = false;\n        })\n        exp.state.next('DELAY')\n      break;\n\n      case 'GO':\n        exp.state.once(() => {\n          overlayText.element.innerText = `Move left or right to match the target below using left or right key. \n Press s Key to End the experiment.\n STEP: ${trial.stepSize} TN: ${trial.trialNumber} Attempt:${trial.attempt}`;\n          //  \n STEP: ${trial.stepSize} TN: ${trial.trialNumber} Attempt:${trial.attempt}`;\n          // overlayText.element.innerText = `SESSION TYPE: ${exp.cfg.searchParams.get('DAY')} `\n          target.visible = true;\n          console.log(trial.isTrain);\n        });\n\n        mask.visible = false;\n        mask2.visible = false;\n        \n        handleFrameData();\n        if (!cursor.atHome) {\n          overlayText.element.innerText = 'Go to the home position. \n Press s Key to End the experiment';\n          exp.state.next('START')}\n        else {\n          if (moveLeft.lm||moveRight.lm) {\n            exp.state.next('MOVING');\n          }\n        }\n        break;\n\n      case 'MOVING':\n        exp.state.once(()=>{\n          trial.keyDown = performance.now();\n          mask2.position.setX(-1.5);\n          mask.position.setX(1.5);\n          overlayText.element.innerText = '';\n          if (!trial.isTrain){\n            // landmarks.filter((landmark)=>(landmark.position.x>0.7)||(landmark.position.x<-0.7)).forEach((landmark)=>{landmark.visible=false})\n            landmarks.forEach(lm=>lm.visible=false)\n          }\n        })\n        handleFrameData();\n\n        target.visible= trial.isTrain;\n        if (!cursor.atHome) {\n          overlayText.element.innerText = 'Go to the home position.';\n          exp.state.next('START')}\n        else {\n          // target.visible = false;\n          if (!(moveLeft.lm||moveRight.lm)  && !isKeyDown) {\n            // target.visible = false;\n            exp.state.next('STOP');\n          }\n\n        landmarks.forEach(lm=>lm.visible=trial.isTrain)\n        }\n        break;\n\n      case 'STOP':\n        exp.state.once(() => {              \n          trial.producedTime = performance.now() - trial.keyDown;\n          console.log('produced Time',trial.producedTime);\n          console.log('true Time',trial.trueTime);\n          \n          if (!trial.isTrain){\n            landmarks.filter(l=>(l.position.x>-0.7)||(l.position.x<0.7)).forEach(l=>{l.visible=true})\n          }\n        target.visible= true;\n        if (target.reached) {\n          if (trial.attempt === 1){\n            exp.cfg.score += 1;\n          }\n          if (exp.state.expired(sampleDelay(0.5,1.5))){\n            exp.state.next('FINISH')\n          } \n        }\n        if (trial.isTrain){\n          landmarks.forEach(l=>{l.visible=true})}\n        else{\n          landmarks.filter(l=>(l.position.x>=-2)&(l.position.x<=2)).forEach(l=>{l.visible=true})\n        }\n        overlayText.element.innerText = `Move left or right to match the target below using left or right key. \n Press s Key to End the experiment \n STEP: ${trial.stepSize} TN: ${trial.trialNumber} Attempt:${trial.attempt}`; \n        // \n STEP: ${trial.stepSize} TN: ${trial.trialNumber} Attempt:${trial.attempt}`; \n        trial.currentTargetPos = landmarks[trial.targetId].position.x;\n        \n        \n\n        });\n\n        handleFrameData();\n        if (!cursor.atHome) {\n            overlayText.element.innerText = 'Go to the home position.';\n            exp.state.next('START')}\n          else  {\n            if (target.reached) {\n              if (trial.attempt == 1){\n                exp.state.once(() => exp.cfg.score += 1);\n              }\n              \n              if (exp.state.expired(sampleDelay(0.5,1.5))){\n                exp.state.next('FINISH')\n              } \n            }\n            else{\n              // if (exp.cfg.searchParams.get('DAY')<3){ // for trainingg days\n                if (trial.attempt==2){  // show the  target and current  positiion\n                  target.visible = true;\n                  if(exp.state.expired(sampleDelay(0.5,1.5))){                  \n                    cursor.material.color = new Color( 'hsl(0, 100%, 50%)')// change color to red and restart \n                    // exp.state.next('FINISH')\n                  }\n                }\n              // }else{\n                // if (exp.state.expired(sampleDelay(0.5,1.5))){ //other days  go to finish\n                //     exp.state.next('FINISH')\n                //   }\n              // }\n            }\n          if (moveLeft.lm||moveRight.lm) {\n            trial.attempt +=1;\n            exp.state.next('MOVING');\n          }\n        }\n        break;\n\n      case 'FINISH':\n        exp.firebase.saveTrial(trial);\n        exp.state.next('ADVANCE');\n        break;\n\n      case 'ADVANCE':\n        if (!exp.firebase.saveSuccessful) {\n          break; // wait until firebase save returns successful\n        } else if (exp.firebase.saveFailed) {\n          exp.blocker.fatal(exp.firebase.saveFailed);\n          exp.state.push('BLOCKED');\n        }\n        // Change the code to caluclate score and display\n        // Wrtie score calculating algorithm\n        console.log(\"SCORE\",Math.round(exp.cfg.score/(exp.trialNumber+1)*100,2))\n        scoreText.element.innerText = `Score :  ${Math.round((exp.cfg.score/(exp.trialNumber+1))*100,2)}% \n Trials Completed : ${exp.trialNumber+1}`\n        exp.sceneManager.cssScene.add(scoreText.object)\n        exp.nextTrial();\n        if (exp.trialNumber < exp.numTrials) {\n          exp.state.next('SETUP');\n        } else {\n          exp.complete(); // !!! Critical !!! Must call at end of experiment !!!\n\n          // Clean up\n          DisplayElement.hide(exp.sceneManager.renderer.domElement);\n          DisplayElement.hide(exp.sceneManager.cssRenderer.domElement);\n          exp.fullscreen.exitFullscreen();\n          exp.state.next('SURVEY');\n        }\n        break;\n\n      case 'SURVEY':\n        exp.state.once(() => exp.survey.show());\n        if (exp.cfg.completed && exp.survey?.submitted) {\n          exp.survey.hide();\n          exp.firebase.saveTrial(exp.cfg);\n          exp.state.next('CODE');\n        }\n        break;\n\n      case 'CODE':\n        if (!exp.firebase.saveSuccessful) {\n          break;\n        }\n        exp.state.once(function () {\n          exp.goodbye.show(); // show the goodbye screen w/ code & prolific link\n        });\n        break;\n\n      // The remaining states are interrupt states and can be left alone\n\n      case 'FULLSCREEN':\n        if (!exp.fullscreenInterrupt()) {\n          exp.blocker.hide();\n          exp.state.pop();\n        }\n        break;\n\n      case 'POINTERLOCK':\n        if (!exp.pointerlockInterrupt()) {\n          exp.blocker.hide();\n          exp.state.pop();\n        }\n        break;\n\n      case 'DATABASE':\n        if (!exp.databaseInterrupt()) {\n          exp.blocker.hide();\n          exp.state.pop();\n        }\n        break;\n    }\n  }\n\n  /**\n   * Compute and update stimulus and UI presentation.\n   */\n  function displayFunc() {\n    // Set the color of the home position material\n    home.material.color = new Color(\n      cursor.atHome ? 'hsl(116, 0%, 50%)' : 'hsl(0, 0%, 100%)'\n    );\n\n    cursor.material.color = new Color(\n      exp.state.between('GO','ADVANCE') ? 'hsl(116, 100%, 50%)' : 'hsl(0, 100%, 50%)'\n    )\n    \n    // Show or hide the cursor\n    cursor.visible = exp.state.between('SETUP', 'ADVANCE');\n    // Render\n    exp.sceneManager.render();\n    if (landmarks[0].position.x > parseFloat(landmarkWidth*1.3).toFixed(2)){\n      moveRight.lm = false;\n      moveRight.dot=trial.train?false:moveRight.dot;\n    }\n    if (landmarks[landmarks.length-1].position.x < parseFloat(-landmarkWidth*1.3).toFixed(2)){\n      \n      moveLeft.lm = false;\n      moveLeft.dot=trial.isTrain?false:moveLeft.dot;\n    }\n    \n  }\n\n  /**\n   * Event handlers\n   */\n\n  // Update the cursor position\n  function handleMouseMove(e) {\n    if (!cursor.visible) return;\n    cursor.position.x += (e.movementX * 2) / window.innerHeight;\n    cursor.position.y -= (e.movementY * 2) / window.innerHeight;\n    cursor.position.clamp(exp.cfg.cursorMinXYZ, exp.cfg.cursorMaxXYZ);\n  }\n\n  function handleKeyUp(e) {\n    isKeyDown = false;\n    const keyActions = {\n      'ArrowRight': () => { moveRight = { lm: false, dot: false }; },\n      'ArrowLeft': () => { moveLeft = { lm: false, dot: false }; }\n    };\n    \n    if (keyActions[e.key]) {\n      keyActions[e.key]();\n    }\n  }\n\nfunction handleKeyDown(e) {\n  isKeyDown = true;\n  \n  const keyActions = {\n    'ArrowRight': () => { moveRight = { lm: true, dot: true }; },\n    'ArrowLeft': () => { moveLeft = { lm: true, dot: true }; },\n    [config.stopKey]: () => {\n      exp.trialNumber = exp.numTrials;\n      exp.state.next('ADVANCE');\n    }\n  };\n\n  if (exp.state.between(\"GO\", \"FINISH\") && (e.key === 'ArrowRight' || e.key === 'ArrowLeft')) {\n    keyActions[e.key]();\n  }\n\n  if (e.key === config.stopKey) {\n    keyActions[config.stopKey]();\n  }\n}\n\n  function animate(){\n    requestAnimationFrame(animate);\n  // Get the time difference between frames\n  let deltaTime = clock.getDelta();  // Time elapsed since last frame in seconds  \n  // Define the step size that should occur over 1 second\n  const stepPerSecond = Math.abs(vaToNdC(trial.stepSize, objectDistance, config.screenHeightcm));\n  \n  // Adjust the step for the current frame based on deltaTime\n  const step = stepPerSecond * deltaTime ; // Movement per frame\n  \n    landmarks.forEach(landmark => {\n      if (cursor.atHome){\n      if (moveLeft.lm) {\n        landmark.position.x -= step;\n        \n      }\n      if (moveRight.lm) {\n        landmark.position.x += step;\n      }}\n  });\n\n  dots.forEach(dot=>{\n    if (cursor.atHome){\n      \n      if (dot.life<0){\n            setRandomPosition(dot);\n            dot.life = Math.random() * config.dotLife;\n      }\n  \n    if (moveLeft.dot) {\n      dot.life -= step;\n      dot.position.x -= step;\n    }\n    if (moveRight.dot) {\n      dot.life -= step;\n      dot.position.x += step;\n    }}\n})\n}\nanimate();\n\n// Record frame data\n  function handleFrameData() {\n    trial.t.push(performance.now());\n    trial.state.push(exp.state.current);\n    trial.posn.push(cursor.position.clone()); // clone!\n  }\n\n  // Record state transition data\n  function handleStateChange() {\n    trial?.stateChange?.push(exp.state.current);\n    trial?.stateChangeTime?.push(performance.now());\n  }\n}\n\nwindow.addEventListener('DOMContentLoaded', main);\n", "homeRadius": 0.05, "orthographic": true, "platform": "Other", "previousUser": {"metadata": {"createdAt": "1725548173157", "creationTime": "Thu, 05 Sep 2024 14:56:13 GMT", "lastLoginAt": "1725548173157", "lastSignInTime": "Thu, 05 Sep 2024 14:56:13 GMT"}, "uid": "QZfsIqeSc0hnJmCQyjDbmPmiv982"}, "requireChrome": false, "requireDesktop": true, "score": 0, "targetRadius": 0.04, "timeOrigin": 1726236575094.9, "trialNumber": "info", "userAgent": {"browser": {"name": "Chrome", "version": "128.0.0.0"}, "engine": {"name": "Blink"}, "os": {"name": "macOS", "version": "10.15.7", "versionName": "Catalina"}, "platform": {"type": "desktop", "vendor": "Apple"}, "string": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36"}, "workerId": "5816660"}}}